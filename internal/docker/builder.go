package docker

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/agentregistry-dev/agentregistry/internal/detector"
)

// BuildConfig contains configuration for building Docker images
type BuildConfig struct {
	ServerInfo *detector.MCPServerInfo
	ImageName  string
	ImageTag   string
	Registry   string // e.g., "docker.io/username" or "ghcr.io/username"
	Platform   string // e.g., "linux/amd64,linux/arm64"
}

// Builder handles Docker image building and pushing
type Builder struct {
	config *BuildConfig
}

// NewBuilder creates a new Docker builder
func NewBuilder(config *BuildConfig) *Builder {
	return &Builder{config: config}
}

// Build builds the Docker image
func (b *Builder) Build() error {
	// Generate Dockerfile if it doesn't exist
	if !b.config.ServerInfo.HasDockerfile {
		if err := b.generateDockerfile(); err != nil {
			return fmt.Errorf("failed to generate Dockerfile: %w", err)
		}
	}

	// Generate .dockerignore if it doesn't exist
	if err := b.generateDockerignore(); err != nil {
		return fmt.Errorf("failed to generate .dockerignore: %w", err)
	}

	// Build the image
	fullImageName := b.getFullImageName()
	fmt.Printf("Building Docker image: %s\n", fullImageName)

	args := []string{"build", "-t", fullImageName}
	
	if b.config.Platform != "" {
		args = append(args, "--platform", b.config.Platform)
	}
	
	args = append(args, b.config.ServerInfo.RootDir)

	cmd := exec.Command("docker", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("docker build failed: %w", err)
	}

	fmt.Println("✓ Docker image built successfully")
	return nil
}

// Push pushes the Docker image to the registry
func (b *Builder) Push() error {
	fullImageName := b.getFullImageName()
	fmt.Printf("Pushing Docker image: %s\n", fullImageName)

	cmd := exec.Command("docker", "push", fullImageName)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("docker push failed: %w", err)
	}

	fmt.Println("✓ Docker image pushed successfully")
	return nil
}

// getFullImageName returns the full image name with registry and tag
func (b *Builder) getFullImageName() string {
	if b.config.Registry != "" {
		return fmt.Sprintf("%s/%s:%s", b.config.Registry, b.config.ImageName, b.config.ImageTag)
	}
	return fmt.Sprintf("%s:%s", b.config.ImageName, b.config.ImageTag)
}

// GetImageReference returns the full image reference for storage
func (b *Builder) GetImageReference() string {
	return b.getFullImageName()
}

// generateDockerfile creates a Dockerfile based on the detected server type
func (b *Builder) generateDockerfile() error {
	// kmcp servers already have a Dockerfile
	if b.config.ServerInfo.Type == detector.TypeKMCP {
		fmt.Println("✓ Using existing Dockerfile from kmcp")
		return nil
	}

	var dockerfile string

	switch b.config.ServerInfo.Type {
	case detector.TypeNPM:
		dockerfile = b.generateNPMDockerfile()
	case detector.TypeUV:
		dockerfile = b.generateUVDockerfile()
	default:
		return fmt.Errorf("unsupported server type: %s", b.config.ServerInfo.Type)
	}

	dockerfilePath := filepath.Join(b.config.ServerInfo.RootDir, "Dockerfile")
	if err := os.WriteFile(dockerfilePath, []byte(dockerfile), 0644); err != nil {
		return fmt.Errorf("failed to write Dockerfile: %w", err)
	}

	fmt.Printf("✓ Generated Dockerfile at %s\n", dockerfilePath)
	return nil
}

func (b *Builder) generateNPMDockerfile() string {
	info := b.config.ServerInfo
	
	// Determine base image and commands based on package manager
	var installCmd string
	switch info.PackageManager {
	case "pnpm":
		installCmd = "RUN corepack enable pnpm && pnpm install --frozen-lockfile"
	case "yarn":
		installCmd = "RUN corepack enable yarn && yarn install --frozen-lockfile"
	default:
		installCmd = "RUN npm ci"
	}

	return fmt.Sprintf(`# Generated by arctl
FROM node:20-slim

WORKDIR /app

# Copy package files
COPY package*.json ./
%s

# Copy application code
COPY . .

# Build if needed (uncomment if you have a build step)
# RUN npm run build

# Expose any ports if needed
# EXPOSE 3000

# Run the MCP server
CMD ["node", "%s"]
`, installCmd, info.EntryPoint)
}

func (b *Builder) generateUVDockerfile() string {
	info := b.config.ServerInfo

	if info.PackageManager == "uv" {
		return fmt.Sprintf(`# Generated by arctl
FROM ghcr.io/astral-sh/uv:python3.12-bookworm-slim

WORKDIR /app

# Copy dependency files
COPY pyproject.toml uv.lock* ./

# Install dependencies
RUN uv sync --frozen --no-dev

# Copy application code
COPY . .

# Run the MCP server
CMD ["uv", "run", "%s"]
`, info.EntryPoint)
	}

	// Standard Python/pip-based
	return fmt.Sprintf(`# Generated by arctl
FROM python:3.12-slim

WORKDIR /app

# Copy dependency files
COPY requirements.txt ./

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Run the MCP server
CMD ["python", "%s"]
`, info.EntryPoint)
}

func (b *Builder) generateDockerignore() error {
	dockerignorePath := filepath.Join(b.config.ServerInfo.RootDir, ".dockerignore")
	
	// Don't overwrite if it exists
	if _, err := os.Stat(dockerignorePath); err == nil {
		return nil
	}

	var content string
	switch b.config.ServerInfo.Type {
	case detector.TypeNPM:
		content = `# Generated by arctl
node_modules
npm-debug.log
.env
.env.local
.git
.gitignore
.DS_Store
*.log
dist
build
.next
coverage
`
	case detector.TypeUV:
		content = `# Generated by arctl
__pycache__
*.py[cod]
*$py.class
*.so
.Python
.env
.venv
env/
venv/
.git
.gitignore
.DS_Store
*.log
.pytest_cache
.coverage
dist
build
*.egg-info
`
	}

	if err := os.WriteFile(dockerignorePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write .dockerignore: %w", err)
	}

	return nil
}

// CheckDockerInstalled checks if Docker is installed and running
func CheckDockerInstalled() error {
	cmd := exec.Command("docker", "version")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("Docker is not installed or not running. Please install Docker and ensure the Docker daemon is running")
	}
	return nil
}

// CheckDockerLogin checks if user is logged in to the registry
func CheckDockerLogin(registry string) error {
	// Extract registry host from full path
	host := strings.Split(registry, "/")[0]
	
	cmd := exec.Command("docker", "info")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to check docker info: %w", err)
	}

	// Basic check - ideally we'd parse docker config
	if !strings.Contains(string(output), "Username") {
		fmt.Printf("⚠️  Warning: You may not be logged in to %s\n", host)
		fmt.Printf("Run: docker login %s\n", host)
	}

	return nil
}

